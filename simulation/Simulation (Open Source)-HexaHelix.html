<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexa-Helix Stellarator - 6-fold Magnetic Helix Symmetry</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0f1629 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            min-height: 100vh;
        }
        
        #canvas-container {
            flex: 1;
            min-width: 60%;
            min-height: 500px;
            position: relative;
        }
        
        #info-panel {
            width: 40%;
            min-width: 350px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: 100vh;
        }
        
        h1 {
            font-size: 1.8em;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #ff6b35, #f7931e, #ffcc00, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: #ff6b35;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #ff6b35;
            padding-bottom: 5px;
        }
        
        p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #e0e0e0;
            font-size: 0.95em;
        }
        
        .highlight {
            background: linear-gradient(90deg, rgba(255, 107, 53, 0.2), rgba(0, 212, 255, 0.2));
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ff6b35;
            margin: 20px 0;
        }
        
        .specs-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .spec-item {
            padding: 12px;
            border-radius: 8px;
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
        }
        
        .spec-item strong {
            color: #ffcc00;
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        
        .spec-item span {
            color: #fff;
            font-size: 1.1em;
        }
        
        .controls {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #ff6b35;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #333;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b35, #ffcc00);
            cursor: pointer;
        }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 107, 53, 0.4);
        }
        
        button.active {
            background: linear-gradient(90deg, #00d4ff, #0099cc);
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            font-size: 0.85em;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #ff6b35;
        }
        
        .plasma-info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .plasma-info h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }
        
        .coil-types {
            margin: 15px 0;
        }
        
        .coil-type {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 5px;
        }
        
        .coil-color {
            width: 30px;
            height: 8px;
            border-radius: 4px;
        }
        
        /* Golden Ratio Section */
        .golden-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.1), rgba(230, 126, 34, 0.1));
            border: 1px solid rgba(241, 196, 15, 0.3);
            border-radius: 10px;
        }
        
        .golden-section h3 {
            color: #f1c40f;
            margin-bottom: 15px;
        }
        
        .phi-display {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .phi-display .phi {
            font-size: 2.5em;
            font-weight: bold;
            color: #f1c40f;
            font-family: 'Courier New', monospace;
        }
        
        .phi-display .label {
            color: #ccc;
            font-size: 0.9em;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
        }
        
        .control-row label {
            flex: 1;
            margin: 0;
        }
        
        .control-row input {
            flex: 2;
        }
        
        .control-row .value {
            min-width: 45px;
            text-align: right;
            color: #f1c40f;
            font-family: monospace;
        }
        
        .vmec-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-radius: 8px;
        }
        
        .vmec-btn.iota {
            background: linear-gradient(135deg, #3498db, #9b59b6);
        }
        
        .validation-box {
            margin-top: 15px;
            padding: 12px;
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .validation-box.warning {
            background: rgba(241, 196, 15, 0.1);
            border-left-color: #f1c40f;
        }
        
        @media (max-width: 900px) {
            .container { flex-direction: column; }
            #canvas-container, #info-panel { width: 100%; min-width: 100%; }
            #info-panel { max-height: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="canvas-container">
            <div id="loading">âš›ï¸ Loading Hexa-Helix Stellarator...</div>
        </div>
        
        <div id="info-panel">
            <h1>âš›ï¸ Hexa-Helix Stellarator</h1>
            <h2 style="margin-top: 0; color: #ff006e; border: none;">6-fold Magnetic Helix Symmetry</h2>
            
            <div class="highlight">
                <strong>ğŸ§¬ Interlaced Magnetic Field</strong><br>
                6 <strong>interwoven magnetic helices</strong> (analogous to HexaHelix-DNA) 
                create a self-stabilizing field through <strong>destructive interference</strong>.
            </div>
            
            <h2>ğŸ“Š Technical Specifications</h2>
            <div class="specs-grid">
                <div class="spec-item">
                    <strong>Major Radius</strong>
                    <span>5.5 m</span>
                </div>
                <div class="spec-item">
                    <strong>Minor Radius</strong>
                    <span>0.53 m</span>
                </div>
                <div class="spec-item">
                    <strong>Magnetic Field</strong>
                    <span>3 Tesla</span>
                </div>
                <div class="spec-item">
                    <strong>Plasma Volume</strong>
                    <span>30 mÂ³</span>
                </div>
                <div class="spec-item">
                    <strong>Heating Power</strong>
                    <span>14 MW</span>
                </div>
                <div class="spec-item">
                    <strong>Plasma Temp.</strong>
                    <span>100 million Â°C</span>
                </div>
                <div class="spec-item">
                    <strong>Symmetry</strong>
                    <span>6-fold (n=6) HEXA</span>
                </div>
                <div class="spec-item">
                    <strong>Helix Strands</strong>
                    <span>6 interwoven</span>
                </div>
            </div>
            
            <h2>ğŸ§² Interlaced Helix System</h2>
            <div class="coil-types">
                <div class="coil-type">
                    <div class="coil-color" style="background: linear-gradient(90deg, #ff0066, #8a2be2);"></div>
                    <span><strong>6 Interwoven Helices</strong> - DNA-like wrapping</span>
                </div>
                <div class="coil-type">
                    <div class="coil-color" style="background: linear-gradient(90deg, #00ffff, #00cccc);"></div>
                    <span><strong>Interference Zones</strong> - Destructive (Cyan)</span>
                </div>
                <div class="coil-type">
                    <div class="coil-color" style="background: linear-gradient(90deg, #ff006e, #ffffff);"></div>
                    <span><strong>Plasma Core</strong> - Stabilized by interlacing</span>
                </div>
            </div>
            
            <div class="plasma-info">
                <h3>ğŸ”¥ Self-Stabilizing Field</h3>
                <p>
                    The 6 helices are <strong>phase-shifted</strong> (60Â° each) so disturbances 
                    at crossing points <strong>cancel each other out</strong>. â†’ <strong>Destructive Interference</strong>
                </p>
            </div>
            
            <h2>ğŸ® Controls</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Rotation Speed:</label>
                    <input type="range" id="speed" min="0" max="100" value="30">
                </div>
                <div class="control-group">
                    <label>Coil Twist (Ï†=0.618):</label>
                    <input type="range" id="twist" min="10" max="100" value="62">
                </div>
                <div class="control-group">
                    <label>Plasma Intensity:</label>
                    <input type="range" id="plasmaIntensity" min="0" max="100" value="70">
                </div>
                <div>
                    <button onclick="toggleAutoRotate()">Auto-Rotation</button>
                    <button onclick="togglePlasma()">Plasma On/Off</button>
                    <button onclick="toggleCoils()">Coils On/Off</button>
                    <button onclick="resetView()">Reset</button>
                    <button onclick="exportToSTL()" style="background: #4CAF50;">ğŸ“¥ STL</button>
                </div>
            </div>
            
            <!-- Golden Ratio Section -->
            <div class="golden-section">
                <h3>ğŸŒ€ Golden Ratio Optimization</h3>
                
                <div class="phi-display">
                    <div class="phi">Ï† = 0.618</div>
                    <div class="label">Goldener Schnitt - Optimales Interlacing</div>
                </div>
                
                <div class="control-row">
                    <label>Helix Turns (N=6):</label>
                    <input type="range" id="helixTurns" min="4" max="16" value="10" step="1">
                    <span class="value" id="turnsValue">10</span>
                </div>
                
                <div class="control-row">
                    <label>Kelvin Îµâ‚‚:</label>
                    <input type="range" id="kelvinEps" min="0" max="100" value="30" step="5">
                    <span class="value" id="epsValue">0.030</span>
                </div>
                
                <button class="vmec-btn" onclick="exportVMECBoundary()">
                    ğŸ“¤ Export VMEC Boundary
                </button>
                
                <button class="vmec-btn iota" onclick="showIotaProfile()">
                    ğŸ“Š Show Iota Profile
                </button>
                
                <div class="validation-box" id="validationStatus">
                    <strong>Wave 2 Status:</strong> Ready for VMEC<br>
                    <small>Î²-Target: 5% | Iota-Range: [0.8, 1.1]</small>
                </div>
            </div>
            
            <h2>ğŸ¨ Legend</h2>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #ff0066;"></div><span>Helix 1</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ff6b35;"></div><span>Helix 2</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ffcc00;"></div><span>Helix 3</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #00ff88;"></div><span>Helix 4</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #00d4ff;"></div><span>Helix 5</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #8a2be2;"></div><span>Helix 6</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ff006e;"></div><span>Plasma</span></div>
            </div>
            
            <h2>ğŸ”¬ Physical Advantages</h2>
            <p><strong>Intrinsic Stability:</strong> No external correction systems needed.</p>
            <p><strong>MHD Damping:</strong> Magnetohydrodynamic instabilities suppressed.</p>
            <p><strong>Disruption Resistance:</strong> No sudden plasma collapses.</p>
            <p><strong>Self-Organization:</strong> System finds stable state automatically.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HEXA-HELIX STELLARATOR v2.0 - GOLDEN RATIO OPTIMIZED
        // Twin Code Analysis (Mensch + KI), January 2026
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Configuration
        const config = {
            numHelices: 6,
            helixTurns: 10,
            twistAmount: 0.618,  // Golden Ratio!
            majorRadius: 5.5,
            minorRadius: 1.2,
            kelvinResonance: {
                epsilon1: 0.15,
                epsilon2: 0.03,
                alpha: Math.PI / 6
            },
            vmec: {
                mpol: 12,
                ntor: 12,
                ns: 99,
                iotaMin: 0.8,
                iotaMax: 1.1
            }
        };
        
        // Scene variables
        let scene, camera, renderer;
        let stellarator, coilGroup, plasmaGroup;
        let autoRotate = true;
        let rotationSpeed = 0.003;
        let showPlasma = true;
        let showCoils = true;
        let twistAmount = config.twistAmount;
        let plasmaIntensity = 0.7;
        let helixTurns = config.helixTurns;
        
        const moduleColors = [
            0xff0066, 0xff6b35, 0xffcc00,
            0x00ff88, 0x00d4ff, 0x8a2be2
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function init() {
            const container = document.getElementById('canvas-container');
            const loading = document.getElementById('loading');
            
            if (typeof THREE === 'undefined') {
                loading.innerHTML = 'âŒ THREE.js konnte nicht geladen werden';
                loading.style.color = '#ff0000';
                return;
            }
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 8, 18);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Lights
            scene.add(new THREE.AmbientLight(0x404040, 0.4));
            
            const light1 = new THREE.PointLight(0xff6b35, 1.5, 50);
            light1.position.set(15, 10, 10);
            scene.add(light1);
            
            const light2 = new THREE.PointLight(0x00d4ff, 1.2, 50);
            light2.position.set(-15, -10, 10);
            scene.add(light2);
            
            const light3 = new THREE.PointLight(0xffffff, 0.8, 50);
            light3.position.set(0, 15, -10);
            scene.add(light3);
            
            // Create Stellarator
            createStellarator();
            
            // Mouse controls
            setupControls();
            
            // Hide loading
            loading.style.display = 'none';
            
            // Resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            animate();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CREATE STELLARATOR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createStellarator() {
            // Clean up existing
            if (stellarator) {
                scene.remove(stellarator);
                stellarator.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
            }
            
            stellarator = new THREE.Group();
            coilGroup = new THREE.Group();
            plasmaGroup = new THREE.Group();
            
            const majorRadius = config.majorRadius;
            const minorRadius = config.minorRadius;
            const numHelices = config.numHelices;
            const pointsPerHelix = 400;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 6 INTERLACED HELICES with Kelvin Resonance
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            for (let h = 0; h < numHelices; h++) {
                const phaseOffset = (h / numHelices) * Math.PI * 2;
                const color = moduleColors[h];
                const helixPoints = [];
                
                for (let i = 0; i <= pointsPerHelix; i++) {
                    const t = (i / pointsPerHelix) * Math.PI * 2;
                    const helixAngle = t * helixTurns + phaseOffset;
                    
                    // Kelvin-Resonanz Breathing Function
                    const { epsilon1, epsilon2, alpha } = config.kelvinResonance;
                    const breathing = 1 + epsilon1 * Math.sin(6 * t + phaseOffset) 
                                        + epsilon2 * Math.sin(12 * t + phaseOffset * 2 + alpha);
                    
                    const r = minorRadius * breathing * twistAmount;
                    
                    const torusX = Math.cos(t) * majorRadius;
                    const torusZ = Math.sin(t) * majorRadius;
                    const normalX = -Math.cos(t);
                    const normalZ = -Math.sin(t);
                    
                    const x = torusX + Math.cos(helixAngle) * r * normalX;
                    const y = Math.sin(helixAngle) * r;
                    const z = torusZ + Math.cos(helixAngle) * r * normalZ;
                    
                    helixPoints.push(new THREE.Vector3(x, y, z));
                }
                
                const curve = new THREE.CatmullRomCurve3(helixPoints, true);
                
                // Main helix tube
                const tubeGeo = new THREE.TubeGeometry(curve, pointsPerHelix, 0.1, 8, true);
                const tubeMat = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.85
                });
                coilGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
                
                // Glowing core
                const coreGeo = new THREE.TubeGeometry(curve, pointsPerHelix, 0.03, 6, true);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
                coilGroup.add(new THREE.Mesh(coreGeo, coreMat));
                
                // Field nodes
                for (let n = 0; n < helixTurns * 2; n++) {
                    const point = curve.getPoint(n / (helixTurns * 2));
                    const nodeGeo = new THREE.SphereGeometry(0.15, 12, 12);
                    const nodeMat = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    });
                    const node = new THREE.Mesh(nodeGeo, nodeMat);
                    node.position.copy(point);
                    coilGroup.add(node);
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PLASMA CORE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const plasmaPoints = [];
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * Math.PI * 2;
                const mod = 0.1 * Math.sin(t * 6);
                plasmaPoints.push(new THREE.Vector3(
                    Math.cos(t) * (majorRadius + mod),
                    mod * 0.5,
                    Math.sin(t) * (majorRadius + mod)
                ));
            }
            
            const plasmaCurve = new THREE.CatmullRomCurve3(plasmaPoints, true);
            
            const plasmaGeo = new THREE.TubeGeometry(plasmaCurve, 200, 0.4 * plasmaIntensity, 12, true);
            const plasmaMat = new THREE.MeshPhongMaterial({
                color: 0xff006e,
                emissive: 0xff006e,
                emissiveIntensity: 0.7,
                transparent: true,
                opacity: 0.5
            });
            plasmaGroup.add(new THREE.Mesh(plasmaGeo, plasmaMat));
            
            // Hot core
            const hotCoreGeo = new THREE.TubeGeometry(plasmaCurve, 200, 0.15 * plasmaIntensity, 8, true);
            const hotCoreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
            plasmaGroup.add(new THREE.Mesh(hotCoreGeo, hotCoreMat));
            
            // Reference torus
            const torusGeo = new THREE.TorusGeometry(majorRadius, 0.02, 8, 100);
            const torusMat = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
            const refTorus = new THREE.Mesh(torusGeo, torusMat);
            refTorus.rotation.x = Math.PI / 2;
            stellarator.add(refTorus);
            
            stellarator.add(coilGroup);
            stellarator.add(plasmaGroup);
            scene.add(stellarator);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONTROLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setupControls() {
            let isDragging = false;
            let prevX = 0, prevY = 0;
            
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', e => {
                isDragging = true;
                prevX = e.clientX;
                prevY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', e => {
                if (!isDragging) return;
                stellarator.rotation.y += (e.clientX - prevX) * 0.01;
                stellarator.rotation.x += (e.clientY - prevY) * 0.01;
                prevX = e.clientX;
                prevY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
            
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                camera.position.z = Math.max(10, Math.min(40, camera.position.z + e.deltaY * 0.02));
            });
            
            // Touch support
            canvas.addEventListener('touchstart', e => {
                isDragging = true;
                prevX = e.touches[0].clientX;
                prevY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchmove', e => {
                if (!isDragging) return;
                stellarator.rotation.y += (e.touches[0].clientX - prevX) * 0.01;
                stellarator.rotation.x += (e.touches[0].clientY - prevY) * 0.01;
                prevX = e.touches[0].clientX;
                prevY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchend', () => isDragging = false);
            
            // Slider controls
            document.getElementById('speed').addEventListener('input', e => {
                rotationSpeed = e.target.value / 5000;
            });
            
            document.getElementById('twist').addEventListener('input', e => {
                twistAmount = e.target.value / 100;
                createStellarator();
            });
            
            document.getElementById('plasmaIntensity').addEventListener('input', e => {
                plasmaIntensity = e.target.value / 100;
                createStellarator();
            });
            
            document.getElementById('helixTurns').addEventListener('input', e => {
                helixTurns = parseInt(e.target.value);
                document.getElementById('turnsValue').textContent = helixTurns;
                config.helixTurns = helixTurns;
                createStellarator();
            });
            
            document.getElementById('kelvinEps').addEventListener('input', e => {
                const val = e.target.value / 1000;
                config.kelvinResonance.epsilon2 = val;
                document.getElementById('epsValue').textContent = val.toFixed(3);
                createStellarator();
            });
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ANIMATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate && stellarator) {
                stellarator.rotation.y += rotationSpeed;
            }
            
            renderer.render(scene, camera);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
        }
        
        function togglePlasma() {
            showPlasma = !showPlasma;
            if (plasmaGroup) plasmaGroup.visible = showPlasma;
        }
        
        function toggleCoils() {
            showCoils = !showCoils;
            if (coilGroup) coilGroup.visible = showCoils;
        }
        
        function resetView() {
            if (stellarator) {
                stellarator.rotation.set(0, 0, 0);
            }
            camera.position.set(0, 8, 18);
            camera.lookAt(0, 0, 0);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VMEC EXPORT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function calculateFourierCoefficients() {
            const Bmn = [];
            const { mpol, ntor } = config.vmec;
            const base = config.minorRadius / config.majorRadius;
            
            for (let m = 0; m <= mpol; m++) {
                for (let n = -ntor; n <= ntor; n++) {
                    if (n % 6 === 0 || n === 0) {
                        let amplitude;
                        if (m === 0 && n === 0) amplitude = config.majorRadius;
                        else if (m === 1 && n === 0) amplitude = config.minorRadius;
                        else if (m === 0 && n === 6) amplitude = base * 0.05;
                        else if (m === 1 && n === 6) amplitude = base * 0.02;
                        else amplitude = base * Math.exp(-0.5 * (Math.abs(m) + Math.abs(n) / 6));
                        
                        if (Math.abs(amplitude) > 1e-10) {
                            Bmn.push({ m, n, rbc: amplitude, zbs: amplitude * 0.1 });
                        }
                    }
                }
            }
            return Bmn;
        }
        
        function exportVMECBoundary() {
            const Bmn = calculateFourierCoefficients();
            const { mpol, ntor, ns } = config.vmec;
            
            let vmecInput = `!----- HEXA-HELIX STELLARATOR VMEC INPUT -----
! Generated by Twin Code (Mensch + KI)
! Date: ${new Date().toISOString()}
! Golden Ratio Twist: ${twistAmount.toFixed(4)}
! Helix Turns: ${helixTurns}

&INDATA
  MGRID_FILE = 'none'
  LFREEB = F
  
  NFP = 6
  MPOL = ${mpol}
  NTOR = ${ntor}
  NS_ARRAY = ${ns}
  
  PHIEDGE = 1.0
  CURTOR = 0.0
  
  GAMMA = 0.0
  BLOAT = 1.0
  SPRES_PED = 1.0
  
  PRES_SCALE = 1.0
  AM = 1.0 0.0 0.0 0.0 0.0
  
  NCURR = 0
  
  ! === BOUNDARY COEFFICIENTS (N=6 SYMMETRY) ===
`;

            Bmn.forEach(({ m, n, rbc, zbs }) => {
                vmecInput += `  RBC(${n},${m}) = ${rbc.toFixed(6)}  ZBS(${n},${m}) = ${zbs.toFixed(6)}\n`;
            });

            vmecInput += `
/
&END
`;

            const blob = new Blob([vmecInput], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hexa_helix_vmec_input.txt';
            a.click();
            URL.revokeObjectURL(url);
            
            alert('VMEC Boundary File exported!');
        }
        
        function calculateIotaProfile() {
            const profiles = [];
            const numPoints = 50;
            
            for (let i = 0; i <= numPoints; i++) {
                const s = i / numPoints;
                const iotaAxis = config.helixTurns * config.twistAmount / config.numHelices;
                const shear = 0.15;
                const iota = iotaAxis * (1 + shear * s);
                profiles.push({ s, iota });
            }
            
            const iotaEdge = profiles[profiles.length - 1].iota;
            const warnings = [];
            
            if (Math.abs(iotaEdge - 1.2) < 0.05) {
                warnings.push('âš ï¸ Iota nahe 6/5 Resonanz!');
            }
            if (iotaEdge < config.vmec.iotaMin || iotaEdge > config.vmec.iotaMax) {
                warnings.push(`âš ï¸ Iota auÃŸerhalb [${config.vmec.iotaMin}, ${config.vmec.iotaMax}]`);
            }
            
            return { profiles, warnings, iotaAxis: profiles[0].iota, iotaEdge };
        }
        
        function showIotaProfile() {
            const { profiles, warnings, iotaAxis, iotaEdge } = calculateIotaProfile();
            const statusDiv = document.getElementById('validationStatus');
            
            if (warnings.length > 0) {
                statusDiv.className = 'validation-box warning';
                statusDiv.innerHTML = `
                    <strong>âš ï¸ Iota Warnings:</strong><br>
                    ${warnings.join('<br>')}<br>
                    <small>Î¹(0) = ${iotaAxis.toFixed(4)} â†’ Î¹(edge) = ${iotaEdge.toFixed(4)}</small>
                `;
            } else {
                statusDiv.className = 'validation-box';
                statusDiv.innerHTML = `
                    <strong>âœ… Iota Profile OK:</strong><br>
                    Î¹(0) = ${iotaAxis.toFixed(4)}<br>
                    Î¹(edge) = ${iotaEdge.toFixed(4)}<br>
                    <small>AuÃŸerhalb kritischer Resonanzen</small>
                `;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STL EXPORT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function exportToSTL() {
            let output = 'solid hexa_helix\n';
            
            coilGroup.traverse(obj => {
                if (obj.isMesh && obj.geometry) {
                    const geo = obj.geometry;
                    const pos = geo.getAttribute('position');
                    const idx = geo.index;
                    
                    if (idx) {
                        for (let i = 0; i < idx.count; i += 3) {
                            const a = idx.getX(i), b = idx.getX(i+1), c = idx.getX(i+2);
                            const vA = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(obj.matrixWorld);
                            const vB = new THREE.Vector3().fromBufferAttribute(pos, b).applyMatrix4(obj.matrixWorld);
                            const vC = new THREE.Vector3().fromBufferAttribute(pos, c).applyMatrix4(obj.matrixWorld);
                            
                            const cb = new THREE.Vector3().subVectors(vC, vB);
                            const ab = new THREE.Vector3().subVectors(vA, vB);
                            const normal = cb.cross(ab).normalize();
                            
                            output += `facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                            output += `  outer loop\n`;
                            output += `    vertex ${vA.x} ${vA.y} ${vA.z}\n`;
                            output += `    vertex ${vB.x} ${vB.y} ${vB.z}\n`;
                            output += `    vertex ${vC.x} ${vC.y} ${vC.z}\n`;
                            output += `  endloop\n`;
                            output += `endfacet\n`;
                        }
                    }
                }
            });
            
            output += 'endsolid hexa_helix\n';
            
            const blob = new Blob([output], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hexa_helix_coils.stl';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize
        window.onload = init;
    </script>
</body>
</html>
