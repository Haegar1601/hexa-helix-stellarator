<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexa-Helix Stellarator - 6-fold Magnetic Helix Symmetry</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0f1629 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            min-height: 100vh;
        }
        
        #canvas-container {
            flex: 1;
            min-width: 60%;
            min-height: 500px;
            position: relative;
        }
        
        #info-panel {
            width: 40%;
            min-width: 350px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: 100vh;
        }
        
        h1 {
            font-size: 1.8em;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #ff6b35, #f7931e, #ffcc00, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: #ff6b35;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #ff6b35;
            padding-bottom: 5px;
        }
        
        p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #e0e0e0;
            font-size: 0.95em;
        }
        
        .highlight {
            background: linear-gradient(90deg, rgba(255, 107, 53, 0.2), rgba(0, 212, 255, 0.2));
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ff6b35;
            margin: 20px 0;
        }
        
        .specs-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .spec-item {
            padding: 12px;
            border-radius: 8px;
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
        }
        
        .spec-item strong {
            color: #ffcc00;
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        
        .spec-item span {
            color: #fff;
            font-size: 1.1em;
        }
        
        .controls {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #ff6b35;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #333;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b35, #ffcc00);
            cursor: pointer;
        }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(90deg, #ff6b35, #f7931e);
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 107, 53, 0.4);
        }
        
        button.active {
            background: linear-gradient(90deg, #00d4ff, #0099cc);
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            font-size: 0.85em;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #ff6b35;
        }
        
        .plasma-info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .plasma-info h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }
        
        .coil-types {
            margin: 15px 0;
        }
        
        .coil-type {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 5px;
        }
        
        .coil-color {
            width: 30px;
            height: 8px;
            border-radius: 4px;
        }
        
        /* Golden Ratio Section */
        .golden-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(241, 196, 15, 0.1), rgba(230, 126, 34, 0.1));
            border: 1px solid rgba(241, 196, 15, 0.3);
            border-radius: 10px;
        }
        
        .golden-section h3 {
            color: #f1c40f;
            margin-bottom: 15px;
        }
        
        .phi-display {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .phi-display .phi {
            font-size: 2.5em;
            font-weight: bold;
            color: #f1c40f;
            font-family: 'Courier New', monospace;
        }
        
        .phi-display .label {
            color: #ccc;
            font-size: 0.9em;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
        }
        
        .control-row label {
            flex: 1;
            margin: 0;
        }
        
        .control-row input {
            flex: 2;
        }
        
        .control-row .value {
            min-width: 45px;
            text-align: right;
            color: #f1c40f;
            font-family: monospace;
        }
        
        .vmec-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-radius: 8px;
        }
        
        .vmec-btn.iota {
            background: linear-gradient(135deg, #3498db, #9b59b6);
        }
        
        .validation-box {
            margin-top: 15px;
            padding: 12px;
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .validation-box.warning {
            background: rgba(241, 196, 15, 0.1);
            border-left-color: #f1c40f;
        }
        
        @media (max-width: 900px) {
            .container { flex-direction: column; }
            #canvas-container, #info-panel { width: 100%; min-width: 100%; }
            #info-panel { max-height: none; }
        }
        
        /* Extended Features Styles */
        .extended-controls {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 10px;
        }
        
        .extended-controls h3 {
            color: #00d4ff;
            margin-bottom: 12px;
            font-size: 1em;
        }
        
        .extended-controls .btn-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .extended-controls button {
            flex: 1 1 45%;
            min-width: 140px;
            padding: 10px 8px;
            font-size: 0.85em;
            margin: 0;
        }
        
        .physics-readout {
            margin-top: 15px;
            padding: 15px;
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 10px;
        }
        
        .physics-readout h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }
        
        .physics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .physics-item {
            text-align: center;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }
        
        .physics-item .value {
            font-size: 1.2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .physics-item .label {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 2px;
        }
        
        .physics-item.warning .value {
            color: #e74c3c;
        }
        
        .physics-item.ok .value {
            color: #2ecc71;
        }
        
        .physics-item.info .value {
            color: #f1c40f;
        }
        
        #poincare-canvas {
            position: absolute;
            top: 10px;
            left: 10px;
            border: 2px solid #ff6b35;
            border-radius: 8px;
            background: rgba(0,0,0,0.85);
            display: none;
            z-index: 100;
        }
        
        #poincare-close {
            position: absolute;
            top: 15px;
            left: 385px;
            background: #e74c3c;
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 28px;
            text-align: center;
            display: none;
            z-index: 101;
            padding: 0;
            margin: 0;
        }
        
        #crosssection-canvas {
            position: absolute;
            bottom: 10px;
            left: 10px;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            background: rgba(0,0,0,0.9);
            display: none;
            z-index: 100;
        }
        
        #crosssection-close {
            position: absolute;
            bottom: 390px;
            left: 385px;
            background: #e74c3c;
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 28px;
            text-align: center;
            display: none;
            z-index: 101;
            padding: 0;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="canvas-container">
            <div id="loading">âš›ï¸ Loading Hexa-Helix Stellarator...</div>
            <canvas id="poincare-canvas" width="400" height="400"></canvas>
            <button id="poincare-close" onclick="togglePoincare()">âœ•</button>
            <canvas id="crosssection-canvas" width="400" height="400"></canvas>
            <button id="crosssection-close" onclick="toggleCrossSection()">âœ•</button>
        </div>
        
        <div id="info-panel">
            <h1>âš›ï¸ Hexa-Helix Stellarator</h1>
            <h2 style="margin-top: 0; color: #ff006e; border: none;">6-fold Magnetic Helix Symmetry</h2>
            
            <div class="highlight">
                <strong>ğŸ§¬ Interlaced Magnetic Field</strong><br>
                6 <strong>interwoven magnetic helices</strong> (analogous to HexaHelix-DNA) 
                create a self-stabilizing field through <strong>destructive interference</strong>.
            </div>
            
            <h2>ğŸ“Š Technical Specifications</h2>
            <div class="specs-grid">
                <div class="spec-item">
                    <strong>Major Radius (R)</strong>
                    <span>5.5 m</span>
                </div>
                <div class="spec-item">
                    <strong>Minor Radius (a)</strong>
                    <span>0.53 m</span>
                </div>
                <div class="spec-item">
                    <strong>Aspect Ratio (A=R/a)</strong>
                    <span>10.4</span>
                </div>
                <div class="spec-item">
                    <strong>Magnetic Field (Bâ‚€)</strong>
                    <span>3 Tesla</span>
                </div>
                <div class="spec-item">
                    <strong>Plasma Volume</strong>
                    <span>30 mÂ³</span>
                </div>
                <div class="spec-item">
                    <strong>Heating Power</strong>
                    <span>14 MW</span>
                </div>
                <div class="spec-item">
                    <strong>Plasma Temp.</strong>
                    <span>100 Mio. K</span>
                </div>
                <div class="spec-item">
                    <strong>Symmetry (N)</strong>
                    <span>6-fold (N=6)</span>
                </div>
            </div>
            
            <h2>ğŸ§² Interlaced Helix System</h2>
            <div class="coil-types">
                <div class="coil-type">
                    <div class="coil-color" style="background: linear-gradient(90deg, #ff0066, #8a2be2);"></div>
                    <span><strong>6 Interwoven Helices</strong> - DNA-like wrapping</span>
                </div>
                <div class="coil-type">
                    <div class="coil-color" style="background: linear-gradient(90deg, #00ffff, #00cccc);"></div>
                    <span><strong>Interference Zones</strong> - Destructive (Cyan)</span>
                </div>
                <div class="coil-type">
                    <div class="coil-color" style="background: linear-gradient(90deg, #ff006e, #ffffff);"></div>
                    <span><strong>Plasma Core</strong> - Stabilized by interlacing</span>
                </div>
            </div>
            
            <div class="plasma-info">
                <h3>ğŸ”¥ Self-Stabilizing Field</h3>
                <p>
                    The 6 helices are <strong>phase-shifted</strong> (60Â° each) so disturbances 
                    at crossing points <strong>cancel each other out</strong>. â†’ <strong>Destructive Interference</strong>
                </p>
            </div>
            
            <h2>ğŸ® Controls</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Rotation Speed:</label>
                    <input type="range" id="speed" min="0" max="100" value="8">
                </div>
                <div class="control-group">
                    <label>Coil Twist (Ï†=0.618):</label>
                    <input type="range" id="twist" min="10" max="100" value="62">
                </div>
                <div class="control-group">
                    <label>Plasma Intensity:</label>
                    <input type="range" id="plasmaIntensity" min="0" max="100" value="70">
                </div>
                <div>
                    <button onclick="toggleAutoRotate()">Auto-Rotation</button>
                    <button onclick="togglePlasma()">Plasma On/Off</button>
                    <button onclick="toggleCoils()">Coils On/Off</button>
                    <button onclick="resetView()">Reset</button>
                    <button onclick="exportToSTL()" style="background: #4CAF50;">ğŸ“¥ STL</button>
                </div>
            </div>
            
            <!-- Extended View Controls -->
            <div class="extended-controls">
                <h3>ğŸ”¬ Extended Views</h3>
                <div class="btn-grid">
                    <button onclick="toggleFieldLines()" id="fieldBtn">ğŸ§² Field Lines On</button>
                    <button onclick="togglePoincare()" id="poincareBtn">ğŸ“Š PoincarÃ© Plot</button>
                    <button onclick="toggleCrossSection()" id="crossBtn">âœ‚ï¸ Cross Section</button>
                    <button onclick="toggleTemperature()" id="tempBtn">ğŸŒ¡ï¸ Temperature On</button>
                    <button onclick="toggleParticles()" id="particleBtn" class="active">âœ¨ Particles Off</button>
                </div>
            </div>
            
            <!-- Live Physics Readout -->
            <div class="physics-readout">
                <h3>ğŸ“ˆ Live Physics</h3>
                <div class="physics-grid">
                    <div class="physics-item ok" id="betaItem">
                        <div class="value" id="betaValue">4.8%</div>
                        <div class="label">Î² (Beta)</div>
                    </div>
                    <div class="physics-item info" id="iotaItem">
                        <div class="value" id="iotaValue">0.92</div>
                        <div class="label">Î¹ (Iota)</div>
                    </div>
                    <div class="physics-item info" id="shearItem">
                        <div class="value" id="shearValue">0.15</div>
                        <div class="label">Shear</div>
                    </div>
                </div>
            </div>
            
            <!-- Golden Ratio Section -->
            <div class="golden-section">
                <h3>ğŸŒ€ Golden Ratio Optimization</h3>
                
                <div class="phi-display">
                    <div class="phi">Ï† = 0.618</div>
                    <div class="label">Golden Ratio - Optimal Interlacing</div>
                </div>
                
                <div class="control-row">
                    <label>Helix Turns (N=6):</label>
                    <input type="range" id="helixTurns" min="6" max="10" value="8" step="2">
                    <span class="value" id="turnsValue">8</span>
                </div>
                
                <div class="control-row">
                    <label>Kelvin Îµâ‚‚:</label>
                    <input type="range" id="kelvinEps" min="0" max="100" value="30" step="5">
                    <span class="value" id="epsValue">0.030</span>
                </div>
                
                <button class="vmec-btn" onclick="exportVMECBoundary()">
                    ğŸ“¤ Export VMEC Boundary
                </button>
                
                <button class="vmec-btn iota" onclick="showIotaProfile()">
                    ğŸ“Š Show Iota Profile
                </button>
                
                <div class="validation-box" id="validationStatus">
                    <strong>Wave 2 Status:</strong> Ready for VMEC<br>
                    <small>Î²-Target: 5% | Iota-Range: [0.8, 1.1]</small>
                </div>
            </div>
            
            <h2>ğŸ¨ Legend</h2>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background: #ff0066;"></div><span>Helix 1</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ff6b35;"></div><span>Helix 2</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ffcc00;"></div><span>Helix 3</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #00ff88;"></div><span>Helix 4</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #00d4ff;"></div><span>Helix 5</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #8a2be2;"></div><span>Helix 6</span></div>
                <div class="legend-item"><div class="legend-color" style="background: #ff006e;"></div><span>Plasma</span></div>
            </div>
            
            <h2>ğŸ”¬ Physical Advantages</h2>
            <p><strong>Intrinsic Stability:</strong> No external correction systems needed.</p>
            <p><strong>MHD Damping:</strong> Magnetohydrodynamic instabilities suppressed.</p>
            <p><strong>Disruption Resistance:</strong> No sudden plasma collapses.</p>
            <p><strong>Self-Organization:</strong> System finds stable state automatically.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HEXA-HELIX STELLARATOR v2.0 - GOLDEN RATIO OPTIMIZED
        // Twin Code Analysis (Mensch + KI), January 2026
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Configuration
        const config = {
            numHelices: 6,
            helixTurns: 8,
            twistAmount: 0.618,  // Golden Ratio!
            majorRadius: 5.5,    // [m] Major radius
            minorRadius: 0.53,   // [m] Minor radius (a)
            aspectRatio: 10.4,   // A = R/a
            magneticField: 3.0,  // [T] On-axis field
            kelvinResonance: {
                epsilon1: 0.15,
                epsilon2: 0.03,
                alpha: Math.PI / 6
            },
            vmec: {
                mpol: 12,
                ntor: 12,
                ns: 99,
                iotaMin: 0.8,
                iotaMax: 1.1
            }
        };
        
        // Scene variables
        let scene, camera, renderer;
        let stellarator, coilGroup, plasmaGroup;
        let fieldLinesGroup, crossSectionGroup, temperatureGroup;
        let autoRotate = true;
        let rotationSpeed = 0.0015;
        let showPlasma = true;
        let showCoils = true;
        let showFieldLines = false;
        let showCrossSection = false;
        let showTemperature = false;
        let showPoincare = false;
        let showParticles = true; // Plasma Partikel standardmÃ¤ÃŸig an
        let twistAmount = config.twistAmount;
        let plasmaIntensity = 0.7;
        let helixTurns = config.helixTurns;  // Default: 8
        
        // Plasma Partikel System
        let plasmaParticleSystem = null;
        let particlePositions = null;
        let particleVelocities = null;
        let particleColors = null;
        const PARTICLE_COUNT = 8000;
        
        // Plasma Fade Animation fÃ¼r weichen Ãœbergang bei Field Lines
        let plasmaTargetOpacity = 0.25;
        let plasmaCurrentOpacity = 0.25;
        let plasmaFadeSpeed = 0.02; // Geschwindigkeit der Ãœberblendung
        let hotCoreTargetOpacity = 0.5;
        let hotCoreCurrentOpacity = 0.5;
        
        const moduleColors = [
            0xff0066, 0xff6b35, 0xffcc00,
            0x00ff88, 0x00d4ff, 0x8a2be2
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function init() {
            const container = document.getElementById('canvas-container');
            const loading = document.getElementById('loading');
            
            if (typeof THREE === 'undefined') {
                loading.innerHTML = 'âŒ THREE.js could not be loaded';
                loading.style.color = '#ff0000';
                return;
            }
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 8, 18);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Lights
            scene.add(new THREE.AmbientLight(0x404040, 0.4));
            
            const light1 = new THREE.PointLight(0xff6b35, 1.5, 50);
            light1.position.set(15, 10, 10);
            scene.add(light1);
            
            const light2 = new THREE.PointLight(0x00d4ff, 1.2, 50);
            light2.position.set(-15, -10, 10);
            scene.add(light2);
            
            const light3 = new THREE.PointLight(0xffffff, 0.8, 50);
            light3.position.set(0, 15, -10);
            scene.add(light3);
            
            // Create Stellarator
            createStellarator();
            
            // Mouse controls
            setupControls();
            
            // Hide loading
            loading.style.display = 'none';
            
            // Resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Start animation
            animate();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CREATE STELLARATOR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createStellarator() {
            // Clean up existing
            if (stellarator) {
                scene.remove(stellarator);
                stellarator.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
            }
            
            stellarator = new THREE.Group();
            coilGroup = new THREE.Group();
            plasmaGroup = new THREE.Group();
            
            const majorRadius = config.majorRadius;
            // For 3D visualization: scale up minor radius for better visibility
            // Real value: 0.53m, but we use ~1.2m for visualization (factor ~2.3)
            const visualMinorRadius = config.minorRadius * 2.3;
            const numHelices = config.numHelices;
            const pointsPerHelix = 400;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 6 INTERLACED HELICES with Kelvin Resonance
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            for (let h = 0; h < numHelices; h++) {
                const phaseOffset = (h / numHelices) * Math.PI * 2;
                const color = moduleColors[h];
                const helixPoints = [];
                
                for (let i = 0; i <= pointsPerHelix; i++) {
                    const t = (i / pointsPerHelix) * Math.PI * 2;
                    const helixAngle = t * helixTurns + phaseOffset;
                    
                    // Kelvin Resonance Breathing Function
                    const { epsilon1, epsilon2, alpha } = config.kelvinResonance;
                    const breathing = 1 + epsilon1 * Math.sin(6 * t + phaseOffset) 
                                        + epsilon2 * Math.sin(12 * t + phaseOffset * 2 + alpha);
                    
                    const r = visualMinorRadius * breathing * twistAmount;
                    
                    const torusX = Math.cos(t) * majorRadius;
                    const torusZ = Math.sin(t) * majorRadius;
                    const normalX = -Math.cos(t);
                    const normalZ = -Math.sin(t);
                    
                    const x = torusX + Math.cos(helixAngle) * r * normalX;
                    const y = Math.sin(helixAngle) * r;
                    const z = torusZ + Math.cos(helixAngle) * r * normalZ;
                    
                    helixPoints.push(new THREE.Vector3(x, y, z));
                }
                
                const curve = new THREE.CatmullRomCurve3(helixPoints, true);
                
                // Main helix tube
                const tubeGeo = new THREE.TubeGeometry(curve, pointsPerHelix, 0.12, 8, true);
                const tubeMat = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.85
                });
                coilGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
                
                // Glowing core
                const coreGeo = new THREE.TubeGeometry(curve, pointsPerHelix, 0.04, 6, true);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
                coilGroup.add(new THREE.Mesh(coreGeo, coreMat));
                
                // Field nodes
                for (let n = 0; n < helixTurns * 2; n++) {
                    const point = curve.getPoint(n / (helixTurns * 2));
                    const nodeGeo = new THREE.SphereGeometry(0.18, 12, 12);
                    const nodeMat = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5
                    });
                    const node = new THREE.Mesh(nodeGeo, nodeMat);
                    node.position.copy(point);
                    coilGroup.add(node);
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PLASMA CORE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const plasmaPoints = [];
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * Math.PI * 2;
                const mod = 0.1 * Math.sin(t * 6);
                plasmaPoints.push(new THREE.Vector3(
                    Math.cos(t) * (majorRadius + mod),
                    mod * 0.5,
                    Math.sin(t) * (majorRadius + mod)
                ));
            }
            
            const plasmaCurve = new THREE.CatmullRomCurve3(plasmaPoints, true);
            
            // Plasma scaled for visualization (visualMinorRadius already defined above)
            const plasmaGeo = new THREE.TubeGeometry(plasmaCurve, 200, visualMinorRadius * plasmaIntensity * 0.6, 12, true);
            const plasmaMat = new THREE.MeshPhongMaterial({
                color: 0xff006e,
                emissive: 0xff006e,
                emissiveIntensity: 0.7,
                transparent: true,
                opacity: plasmaCurrentOpacity,
                depthWrite: false // Bessere Transparenz-Darstellung
            });
            const plasmaMesh = new THREE.Mesh(plasmaGeo, plasmaMat);
            plasmaMesh.name = 'plasmaCore';
            plasmaGroup.add(plasmaMesh);
            
            // Hot core mit Glow-Effekt
            const hotCoreGeo = new THREE.TubeGeometry(plasmaCurve, 200, visualMinorRadius * plasmaIntensity * 0.15, 8, true);
            const hotCoreMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: hotCoreCurrentOpacity,
                depthWrite: false
            });
            const hotCoreMesh = new THREE.Mesh(hotCoreGeo, hotCoreMat);
            hotCoreMesh.name = 'hotCore';
            plasmaGroup.add(hotCoreMesh);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HOT CORE GLOW LAYERS - Weicher strahlender Ãœbergang
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const glowLayers = [
                { radius: 0.25, opacity: 0.6, color: 0xffffcc },  // Innerer Glow (warm weiÃŸ)
                { radius: 0.35, opacity: 0.35, color: 0xffdd88 }, // Mittlerer Glow (gold)
                { radius: 0.45, opacity: 0.15, color: 0xff9966 }  // Ã„uÃŸerer Glow (orange)
            ];
            
            glowLayers.forEach((layer, index) => {
                const glowGeo = new THREE.TubeGeometry(plasmaCurve, 200, visualMinorRadius * plasmaIntensity * layer.radius, 8, true);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity * hotCoreCurrentOpacity,
                    depthWrite: false,
                    side: THREE.BackSide
                });
                const glowMesh = new THREE.Mesh(glowGeo, glowMat);
                glowMesh.name = `hotCoreGlow${index}`;
                plasmaGroup.add(glowMesh);
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PLASMA PARTIKEL SYSTEM - Bewegende Fusionspartikel
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            createPlasmaParticles(plasmaCurve, visualMinorRadius);
            
            // Reference torus
            const torusGeo = new THREE.TorusGeometry(majorRadius, 0.02, 8, 100);
            const torusMat = new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 });
            const refTorus = new THREE.Mesh(torusGeo, torusMat);
            refTorus.rotation.x = Math.PI / 2;
            stellarator.add(refTorus);
            
            stellarator.add(coilGroup);
            stellarator.add(plasmaGroup);
            scene.add(stellarator);
            
            // Aktualisiere erweiterte Features wenn aktiv
            if (showFieldLines) createMagneticFieldLines();
            if (showCrossSection) drawCrossSectionView();
            if (showTemperature) createTemperatureProfile();
            if (showPoincare) drawPoincareSection();
            
            // Update Physics Readout
            updatePhysicsReadout();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLASMA PARTICLE SYSTEM - Animierte Fusionspartikel
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createPlasmaParticles(plasmaCurve, visualMinorRadius) {
            // Entferne altes Partikelsystem falls vorhanden
            if (plasmaParticleSystem) {
                plasmaGroup.remove(plasmaParticleSystem);
                if (plasmaParticleSystem.geometry) plasmaParticleSystem.geometry.dispose();
                if (plasmaParticleSystem.material) plasmaParticleSystem.material.dispose();
            }
            
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            particleColors = new Float32Array(PARTICLE_COUNT * 3);
            
            const majorRadius = config.majorRadius;
            const minorRadius = visualMinorRadius * plasmaIntensity * 0.5;
            
            // Partikel entlang des Torus verteilen (Magnetfeldlinien-Bewegung)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Toroidale Position (um den groÃŸen Ring)
                const toroidal = Math.random() * Math.PI * 2;
                // Poloidale Position (im kleinen Querschnitt)
                const poloidal = Math.random() * Math.PI * 2;
                // Radius vom Zentrum des Querschnitts (mehr Partikel im Kern)
                const r = Math.pow(Math.random(), 0.5) * minorRadius;
                
                // N=6 Helix-Modulation
                const helixMod = 0.1 * Math.sin(toroidal * 6);
                
                // Position berechnen (Torus-Koordinaten)
                const R = majorRadius + r * Math.cos(poloidal) + helixMod;
                const x = R * Math.cos(toroidal);
                const y = r * Math.sin(poloidal) + helixMod * 0.3;
                const z = R * Math.sin(toroidal);
                
                particlePositions[i * 3] = x;
                particlePositions[i * 3 + 1] = y;
                particlePositions[i * 3 + 2] = z;
                
                // Geschwindigkeit: hauptsÃ¤chlich toroidal + Iota-Rotation poloidal
                const iota = helixTurns * twistAmount / config.numHelices;
                const speed = 0.02 + Math.random() * 0.03;
                
                // Toroidale + poloidale Geschwindigkeit (Feldlinien-Verfolgung)
                particleVelocities[i * 3] = speed;     // toroidale Richtung
                particleVelocities[i * 3 + 1] = iota * speed; // poloidale Rotation
                particleVelocities[i * 3 + 2] = toroidal; // Startwinkel speichern
                
                // Farbe: TemperaturabhÃ¤ngig (innen heiÃŸ/weiÃŸ, auÃŸen kÃ¼hler/pink)
                const tempFactor = 1 - (r / minorRadius); // 0 = auÃŸen, 1 = innen
                const hue = 0.95 - tempFactor * 0.15; // Pink â†’ Rot-Orange
                const saturation = 0.3 + (1 - tempFactor) * 0.7;
                const lightness = 0.5 + tempFactor * 0.5; // Innen heller
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            // Partikel-Material mit Glow-Effekt
            const material = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.40,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            plasmaParticleSystem = new THREE.Points(geometry, material);
            plasmaParticleSystem.name = 'plasmaParticles';
            plasmaParticleSystem.visible = showParticles;
            plasmaGroup.add(plasmaParticleSystem);
        }
        
        function updatePlasmaParticles() {
            if (!plasmaParticleSystem || !particlePositions || !showParticles) return;
            
            const majorRadius = config.majorRadius;
            const minorRadius = config.minorRadius * 2.3 * plasmaIntensity * 0.5;
            const iota = helixTurns * twistAmount / config.numHelices;
            
            // Zeit fÃ¼r Animation - SCHNELLER fÃ¼r sichtbare Bewegung!
            const time = Date.now() * 0.002;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Geschwindigkeit und Startphase
                const speed = particleVelocities[i * 3];
                const startPhase = particleVelocities[i * 3 + 2];
                
                // TOROIDALE Position: Um den groÃŸen Ring
                const toroidal = (startPhase + time * speed) % (Math.PI * 2);
                
                // POLOIDALE Position: Rotation im Querschnitt (folgt Feldlinie)
                const startPoloidal = (i / PARTICLE_COUNT) * Math.PI * 2;
                const poloidal = startPoloidal + toroidal * iota;
                
                // Radius vom Zentrum (verschiedene magnetische FlÃ¤chen)
                const surfaceIndex = i % 5;
                const r = minorRadius * (0.2 + surfaceIndex * 0.16);
                
                // N=6 Stellarator-Shaping
                const helixMod = 0.12 * Math.sin(toroidal * 6);
                
                // Position im poloidalen Querschnitt
                const localR = r * Math.cos(poloidal);
                const localZ = r * Math.sin(poloidal);
                
                // Transformation zu 3D Torus-Koordinaten
                const R = majorRadius + localR + helixMod;
                const x = R * Math.cos(toroidal);
                const y = localZ + helixMod * 0.3;
                const z = R * Math.sin(toroidal);
                
                particlePositions[i * 3] = x;
                particlePositions[i * 3 + 1] = y;
                particlePositions[i * 3 + 2] = z;
                
                // Farbe: Innen (heiÃŸ/weiÃŸ) â†’ AuÃŸen (kÃ¼hler/pink)
                const tempFactor = 1 - (surfaceIndex / 5);
                const hue = 0.95 - tempFactor * 0.12;
                const saturation = 0.4 + (1 - tempFactor) * 0.6;
                const lightness = 0.55 + tempFactor * 0.4;
                
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
            }
            
            // Geometrie aktualisieren
            plasmaParticleSystem.geometry.attributes.position.needsUpdate = true;
            plasmaParticleSystem.geometry.attributes.color.needsUpdate = true;
        }
        
        function toggleParticles() {
            showParticles = !showParticles;
            const btn = document.getElementById('particleBtn');
            
            if (showParticles) {
                if (plasmaParticleSystem) plasmaParticleSystem.visible = true;
                btn.textContent = 'âœ¨ Particles Off';
                btn.classList.add('active');
            } else {
                if (plasmaParticleSystem) plasmaParticleSystem.visible = false;
                btn.textContent = 'âœ¨ Particles On';
                btn.classList.remove('active');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MAGNETIC FIELD LINES (corrected - inside plasma)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createMagneticFieldLines() {
            if (fieldLinesGroup) {
                stellarator.remove(fieldLinesGroup);
                fieldLinesGroup.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
            }
            
            fieldLinesGroup = new THREE.Group();
            
            // Field lines on different magnetic surfaces (Ïˆ = const)
            const numSurfaces = 4;  // Number of magnetic surfaces
            const linesPerSurface = 6;  // Field lines per surface
            
            // Scale minor radius for 3D visualization
            const visualMinorRadius = config.minorRadius * 2.3;
            
            for (let s = 0; s < numSurfaces; s++) {
                // Normalized radius of surface (0 = axis, 1 = edge)
                const psiNorm = (s + 1) / (numSurfaces + 1);
                // Actual minor radius of this surface (scaled for visualization)
                const surfaceRadius = visualMinorRadius * psiNorm * twistAmount * 0.7;
                
                // Color: inside hot (white/yellow) â†’ outside cooler (green/cyan)
                const hue = 0.15 + psiNorm * 0.35; // yellow â†’ green â†’ cyan
                const saturation = 0.8 + psiNorm * 0.2;
                const lightness = 0.7 - psiNorm * 0.2;
                const surfaceColor = new THREE.Color().setHSL(hue, saturation, lightness);
                
                for (let l = 0; l < linesPerSurface; l++) {
                    const points = [];
                    const startAngle = (l / linesPerSurface) * Math.PI * 2;
                    
                    // Iota (rotational transform) - slightly varying with radius
                    const iotaBase = helixTurns * twistAmount / config.numHelices;
                    const iota = iotaBase * (1 + 0.1 * psiNorm); // Shear
                    
                    const numSteps = 400;
                    const numToroidalTurns = 3; // Field line makes 3 toroidal turns
                    
                    for (let t = 0; t <= numSteps; t++) {
                        const toroidal = (t / numSteps) * Math.PI * 2 * numToroidalTurns;
                        const poloidal = startAngle + toroidal * iota;
                        
                        // N=6 Shaping of magnetic surface (Kelvin resonance)
                        const { epsilon1, epsilon2 } = config.kelvinResonance;
                        const shaping = 1 + 
                            epsilon1 * 0.5 * Math.cos(poloidal) + 
                            epsilon2 * Math.cos(2 * poloidal) +
                            0.03 * Math.cos(6 * toroidal); // N=6 toroidal modulation
                        
                        const r_minor = surfaceRadius * shaping;
                        
                        // Position on torus
                        // Local coordinates in poloidal cross-section
                        const localR = r_minor * Math.cos(poloidal);
                        const localZ = r_minor * Math.sin(poloidal);
                        
                        // Transformation to 3D (Torus coordinates)
                        const R = config.majorRadius + localR;
                        const x = R * Math.cos(toroidal);
                        const y = localZ;
                        const z = R * Math.sin(toroidal);
                        
                        points.push(new THREE.Vector3(x, y, z));
                    }
                    
                    const curve = new THREE.CatmullRomCurve3(points);
                    const geometry = new THREE.TubeGeometry(curve, numSteps, 0.015, 4, false);
                    
                    // Verbessertes Material mit Glow-Effekt fÃ¼r weicheren Look
                    const material = new THREE.MeshBasicMaterial({
                        color: surfaceColor,
                        transparent: true,
                        opacity: 0.7,
                        depthWrite: false // Bessere Transparenz-Ãœberlagerung
                    });
                    
                    // Hauptlinie
                    const mainLine = new THREE.Mesh(geometry, material);
                    fieldLinesGroup.add(mainLine);
                    
                    // Ã„uÃŸerer Glow fÃ¼r weicheren Ãœbergang
                    const glowGeometry = new THREE.TubeGeometry(curve, numSteps, 0.035, 4, false);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: surfaceColor,
                        transparent: true,
                        opacity: 0.15,
                        depthWrite: false,
                        side: THREE.BackSide
                    });
                    fieldLinesGroup.add(new THREE.Mesh(glowGeometry, glowMaterial));
                }
            }
            
            fieldLinesGroup.visible = showFieldLines;
            stellarator.add(fieldLinesGroup);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POINCARÃ‰ SECTION (Realistic Field Line Tracing)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function drawPoincareSection() {
            const canvas = document.getElementById('poincare-canvas');
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 400, 400);
            
            // Calculate current iota
            const iotaBase = helixTurns * twistAmount / config.numHelices;
            const shear = 0.15;
            
            // Title
            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 14px Segoe UI';
            ctx.fillText('PoincarÃ© Section (Ï†=0Â°)', 10, 22);
            
            // Explanation
            ctx.fillStyle = '#888';
            ctx.font = '10px Segoe UI';
            ctx.fillText('Field line tracing: each dot = one toroidal transit', 10, 38);
            ctx.fillText(`Î¹(0)=${iotaBase.toFixed(3)} | Î¹(edge)=${(iotaBase * (1 + shear)).toFixed(3)}`, 10, 52);
            
            // Coordinate system
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(200, 70); ctx.lineTo(200, 350);
            ctx.moveTo(50, 210); ctx.lineTo(350, 210);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#666';
            ctx.font = '11px Segoe UI';
            ctx.fillText('R â†’', 340, 215);
            ctx.fillText('Z â†‘', 205, 80);
            
            // Scale markers
            ctx.fillStyle = '#444';
            ctx.font = '9px Segoe UI';
            ctx.fillText('0', 195, 225);
            ctx.fillText('+1m', 310, 225);
            ctx.fillText('-1m', 85, 225);
            
            const { epsilon1, epsilon2 } = config.kelvinResonance;
            const colors = ['#ff006e', '#ff6b35', '#ffcc00', '#00ff88', '#00d4ff'];
            const numSurfaces = 5;
            const cx = 200, cy = 210;
            const scale = 300; // pixels per meter
            
            // Trace field lines on each magnetic surface
            for (let surface = 0; surface < numSurfaces; surface++) {
                ctx.fillStyle = colors[surface];
                
                // Normalized flux coordinate (0 = axis, 1 = edge)
                const psiNorm = (surface + 1) / (numSurfaces + 1);
                const surfaceRadius = config.minorRadius * psiNorm * twistAmount * 0.9;
                
                // Iota varies with radius (shear)
                const iota = iotaBase * (1 + shear * psiNorm);
                
                // Number of field lines to trace on this surface
                const numFieldLines = 4;
                // Number of toroidal transits (punctures)
                const numTransits = 80;
                
                for (let fl = 0; fl < numFieldLines; fl++) {
                    // Starting poloidal angle for this field line
                    const theta0 = (fl / numFieldLines) * Math.PI * 2;
                    
                    for (let transit = 0; transit < numTransits; transit++) {
                        // Poloidal angle after 'transit' toroidal turns
                        // Î¸ = Î¸â‚€ + Î¹ * 2Ï€ * n (where n = number of toroidal transits)
                        const theta = theta0 + iota * 2 * Math.PI * transit;
                        
                        // Apply stellarator shaping (D-shape, triangularity)
                        const shaping = 1 + 
                            epsilon1 * 0.8 * Math.cos(theta) +      // Shafranov shift
                            epsilon2 * 1.5 * Math.cos(2 * theta) +  // Elongation
                            0.06 * Math.cos(3 * theta);              // Triangularity
                        
                        // Position in R-Z plane
                        const r = surfaceRadius * shaping;
                        const R = r * Math.cos(theta);  // Radial displacement from axis
                        const Z = r * Math.sin(theta);  // Vertical position
                        
                        // Convert to canvas coordinates
                        const x = cx + R * scale;
                        const y = cy - Z * scale;  // Flip Y for canvas
                        
                        // Draw point
                        ctx.beginPath();
                        ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Mark magnetic axis
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#888';
            ctx.font = '9px Segoe UI';
            ctx.fillText('Axis', cx + 8, cy + 3);
            
            // Legend (top right)
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(295, 60, 100, 115);
            ctx.strokeStyle = '#555';
            ctx.strokeRect(295, 60, 100, 115);
            
            ctx.fillStyle = '#ccc';
            ctx.font = 'bold 9px Segoe UI';
            ctx.fillText('Ïˆ = Flux Surface', 302, 74);
            
            ctx.font = '10px Segoe UI';
            for (let i = 0; i < numSurfaces; i++) {
                const psi = ((i + 1) / (numSurfaces + 1) * 100).toFixed(0);
                ctx.fillStyle = colors[i];
                ctx.fillRect(302, 82 + i * 15, 10, 10);
                ctx.fillStyle = '#aaa';
                ctx.fillText(`${psi}%`, 318, 91 + i * 15);
            }
            
            // Info box bottom
            ctx.fillStyle = 'rgba(0, 200, 100, 0.1)';
            ctx.fillRect(10, 355, 280, 40);
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 1;
            ctx.strokeRect(10, 355, 280, 40);
            
            ctx.fillStyle = '#2ecc71';
            ctx.font = '10px Segoe UI';
            ctx.fillText('âœ… Closed curves = Good magnetic surfaces', 18, 372);
            ctx.fillText('    Islands/chaos would indicate resonances', 18, 387);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CROSS SECTION VIEW (2D Canvas - clear and understandable)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function drawCrossSectionView() {
            const canvas = document.getElementById('crosssection-canvas');
            const ctx = canvas.getContext('2d');
            const cx = 200, cy = 200; // Center
            const scale = 160; // Scale for display (pixels per meter)
            
            // Background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 400, 400);
            
            // Title
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Segoe UI';
            ctx.fillText('Poloidal Cross Section (Ï†=0Â°)', 10, 25);
            
            ctx.fillStyle = '#888';
            ctx.font = '11px Segoe UI';
            ctx.fillText(`a=${config.minorRadius}m | A=${(config.majorRadius/config.minorRadius).toFixed(1)} | twist=${twistAmount.toFixed(3)}`, 10, 42);
            
            // Coordinate cross
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx, 30); ctx.lineTo(cx, 370);
            ctx.moveTo(30, cy); ctx.lineTo(370, cy);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#666';
            ctx.font = '11px Segoe UI';
            ctx.fillText('R [m]', 340, cy - 10);
            ctx.fillText('Z [m]', cx + 10, 45);
            
            // Scale markers
            ctx.fillStyle = '#555';
            ctx.font = '9px Segoe UI';
            for (let r = -0.5; r <= 0.5; r += 0.25) {
                if (Math.abs(r) > 0.01) {
                    const px = cx + r * scale * 2;
                    ctx.fillText(r.toFixed(2), px - 12, cy + 15);
                }
            }
            for (let z = -0.5; z <= 0.5; z += 0.25) {
                if (Math.abs(z) > 0.01) {
                    const py = cy - z * scale * 2;
                    ctx.fillText(z.toFixed(2), cx + 8, py + 3);
                }
            }
            
            const { epsilon1, epsilon2 } = config.kelvinResonance;
            
            // â•â•â• VACUUM VESSEL (Outer wall) â•â•â•
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const theta = (i / 100) * Math.PI * 2;
                const r = config.minorRadius * 1.8; // Vessel much larger
                const x = cx + r * Math.cos(theta) * scale;
                const y = cy - r * Math.sin(theta) * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // â•â•â• FIRST WALL (Plasma-facing components) â•â•â•
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const theta = (i / 100) * Math.PI * 2;
                const r = config.minorRadius * 1.45; // First wall
                const x = cx + r * Math.cos(theta) * scale;
                const y = cy - r * Math.sin(theta) * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);
            
            // â•â•â• SCRAPE-OFF LAYER (SOL) â•â•â•
            ctx.fillStyle = 'rgba(100, 100, 255, 0.15)';
            ctx.beginPath();
            // Outer edge of SOL (at first wall)
            for (let i = 0; i <= 100; i++) {
                const theta = (i / 100) * Math.PI * 2;
                const r = config.minorRadius * 1.3;
                const x = cx + r * Math.cos(theta) * scale;
                const y = cy - r * Math.sin(theta) * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            // Inner edge of SOL (at LCFS) - reverse direction
            for (let i = 100; i >= 0; i--) {
                const theta = (i / 100) * Math.PI * 2;
                const r = config.minorRadius * (1 + 
                    epsilon1 * Math.cos(theta) +
                    epsilon2 * Math.cos(2 * theta) +
                    0.05 * Math.cos(3 * theta));
                const x = cx + r * Math.cos(theta) * scale;
                const y = cy - r * Math.sin(theta) * scale;
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            // â•â•â• PLASMA EDGE (Last Closed Flux Surface) â•â•â•
            ctx.strokeStyle = '#ff006e';
            ctx.fillStyle = 'rgba(255, 0, 110, 0.2)';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const theta = (i / 100) * Math.PI * 2;
                // Bean-Shape / D-Shape Deformation
                const r = config.minorRadius * (1 + 
                    epsilon1 * Math.cos(theta) +           // Shafranov Shift
                    epsilon2 * Math.cos(2 * theta) +       // Elongation
                    0.05 * Math.cos(3 * theta));           // Triangularity
                const x = cx + r * Math.cos(theta) * scale;
                const y = cy - r * Math.sin(theta) * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // â•â•â• MAGNETIC SURFACES (inner) â•â•â•
            const surfaceColors = ['#ffcc00', '#ff6b35', '#ff006e'];
            for (let s = 0; s < 3; s++) {
                const psiNorm = (s + 1) / 4; // 0.25, 0.5, 0.75
                ctx.strokeStyle = surfaceColors[s];
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const theta = (i / 100) * Math.PI * 2;
                    const r = config.minorRadius * psiNorm * (1 + 
                        epsilon1 * 0.7 * Math.cos(theta) +
                        epsilon2 * 0.5 * Math.cos(2 * theta));
                    const x = cx + r * Math.cos(theta) * scale;
                    const y = cy - r * Math.sin(theta) * scale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // â•â•â• MAGNETIC AXIS (Center) â•â•â•
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#aaa';
            ctx.font = '10px Segoe UI';
            ctx.fillText('Mag. Axis', cx + 8, cy + 4);
            
            // â•â•â• COIL CROSS-SECTIONS (6 Helices) â•â•â•
            // Coils are OUTSIDE the vacuum vessel!
            const coilRadius = config.minorRadius * 2.1; // Outside vessel
            
            for (let h = 0; h < config.numHelices; h++) {
                const phaseOffset = (h / config.numHelices) * Math.PI * 2;
                const helixAngle = 0 * helixTurns + phaseOffset; // At Ï†=0
                
                // Coil position - outside vacuum vessel
                const coilX = cx + Math.cos(helixAngle) * coilRadius * scale;
                const coilY = cy - Math.sin(helixAngle) * coilRadius * scale;
                
                // Coil circle
                const color = new THREE.Color(moduleColors[h]);
                ctx.fillStyle = `rgb(${Math.floor(color.r*255)}, ${Math.floor(color.g*255)}, ${Math.floor(color.b*255)})`;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(coilX, coilY, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Current direction (âŠ™ = out of page, âŠ— = into page)
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(h % 2 === 0 ? 'âŠ™' : 'âŠ—', coilX - 4, coilY + 4);
            }
            
            // â•â•â• LEGEND â•â•â•
            const legendY = 280;
            ctx.font = '9px Segoe UI';
            
            // Vacuum Vessel
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(280, legendY); ctx.lineTo(310, legendY);
            ctx.stroke();
            ctx.fillStyle = '#aaa';
            ctx.fillText('Vacuum Vessel', 315, legendY + 3);
            
            // First Wall
            ctx.strokeStyle = '#666';
            ctx.setLineDash([6, 3]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(280, legendY + 15); ctx.lineTo(310, legendY + 15);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#aaa';
            ctx.fillText('First Wall', 315, legendY + 18);
            
            // SOL
            ctx.fillStyle = 'rgba(100, 100, 255, 0.3)';
            ctx.fillRect(280, legendY + 27, 30, 10);
            ctx.fillStyle = '#aaa';
            ctx.fillText('SOL', 315, legendY + 35);
            
            // Plasma (LCFS)
            ctx.strokeStyle = '#ff006e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(280, legendY + 50); ctx.lineTo(310, legendY + 50);
            ctx.stroke();
            ctx.fillStyle = '#aaa';
            ctx.fillText('LCFS (Plasma)', 315, legendY + 53);
            
            // Mag. Surfaces
            ctx.strokeStyle = '#ffcc00';
            ctx.setLineDash([4, 2]);
            ctx.beginPath();
            ctx.moveTo(280, legendY + 65); ctx.lineTo(310, legendY + 65);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#aaa';
            ctx.fillText('Mag. Surfaces', 315, legendY + 68);
            
            // Coils
            ctx.fillStyle = '#ff6b35';
            ctx.beginPath();
            ctx.arc(295, legendY + 82, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#aaa';
            ctx.fillText('Helix Coils', 315, legendY + 85);
            
            // Info-Box
            ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.fillRect(10, 365, 180, 30);
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 1;
            ctx.strokeRect(10, 350, 180, 40);
            
            ctx.fillStyle = '#00d4ff';
            ctx.font = '10px Segoe UI';
            ctx.fillText(`Îµâ‚ (Shift): ${epsilon1.toFixed(3)}`, 20, 368);
            ctx.fillText(`Îµâ‚‚ (Elongation): ${epsilon2.toFixed(3)}`, 20, 382);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEMPERATURE PROFILE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createTemperatureProfile() {
            if (temperatureGroup) {
                stellarator.remove(temperatureGroup);
                temperatureGroup.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
            }
            
            temperatureGroup = new THREE.Group();
            const plasmaLayers = 5;
            
            for (let layer = 0; layer < plasmaLayers; layer++) {
                const layerPoints = [];
                const layerRadius = 0.1 + layer * 0.12; // From inside to outside
                const temperature = 1 - Math.pow(layer / plasmaLayers, 2); // Parabolic profile
                
                for (let i = 0; i <= 200; i++) {
                    const t = (i / 200) * Math.PI * 2;
                    const mod = 0.08 * Math.sin(t * 6);
                    layerPoints.push(new THREE.Vector3(
                        Math.cos(t) * (config.majorRadius + mod),
                        mod * 0.4,
                        Math.sin(t) * (config.majorRadius + mod)
                    ));
                }
                
                const layerCurve = new THREE.CatmullRomCurve3(layerPoints, true);
                const layerGeo = new THREE.TubeGeometry(layerCurve, 200, layerRadius * plasmaIntensity, 12, true);
                
                // Color: white (hot) â†’ orange â†’ red â†’ dark red (cold)
                const hue = 0.0 + (1 - temperature) * 0.08; // Red-orange range
                const lightness = 0.25 + temperature * 0.65;
                const color = new THREE.Color().setHSL(hue, 1, lightness);
                
                const layerMat = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4 * temperature,
                    transparent: true,
                    opacity: 0.2 + temperature * 0.4
                });
                temperatureGroup.add(new THREE.Mesh(layerGeo, layerMat));
            }
            
            // Hot core (white)
            const corePoints = [];
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * Math.PI * 2;
                corePoints.push(new THREE.Vector3(
                    Math.cos(t) * config.majorRadius,
                    0,
                    Math.sin(t) * config.majorRadius
                ));
            }
            const coreCurve = new THREE.CatmullRomCurve3(corePoints, true);
            const coreGeo = new THREE.TubeGeometry(coreCurve, 200, 0.08 * plasmaIntensity, 8, true);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.95 
            });
            temperatureGroup.add(new THREE.Mesh(coreGeo, coreMat));
            
            temperatureGroup.visible = showTemperature;
            stellarator.add(temperatureGroup);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BETA LIMIT CALCULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function calculateBetaLimit() {
            // Simplified beta calculation for stellarators
            // Î² â‰ˆ 5% is a realistic target for optimized stellarators
            const aspectRatio = config.majorRadius / config.minorRadius;
            const optimalTwist = 0.618; // Golden Ratio
            
            // Beta steigt wenn twist nahe am Optimum
            const twistDeviation = Math.abs(twistAmount - optimalTwist);
            const estimatedBeta = 0.05 * (1 - twistDeviation * 2) * (1 + 0.1 * Math.sin(helixTurns * Math.PI / 6));
            
            // Iota Berechnung
            const iota = helixTurns * twistAmount / config.numHelices;
            
            // Shear
            const shear = 0.15 * (1 + 0.2 * (twistAmount - 0.5));
            
            return { 
                beta: Math.max(0.01, Math.min(0.08, estimatedBeta)), 
                iota: iota,
                shear: shear
            };
        }
        
        function updatePhysicsReadout() {
            const { beta, iota, shear } = calculateBetaLimit();
            
            // Beta Update
            const betaPercent = (beta * 100).toFixed(1);
            document.getElementById('betaValue').textContent = betaPercent + '%';
            const betaItem = document.getElementById('betaItem');
            
            if (beta > 0.06) {
                betaItem.className = 'physics-item warning';
            } else if (beta > 0.04) {
                betaItem.className = 'physics-item ok';
            } else {
                betaItem.className = 'physics-item info';
            }
            
            // Iota Update
            document.getElementById('iotaValue').textContent = iota.toFixed(3);
            const iotaItem = document.getElementById('iotaItem');
            
            // Warning at resonances (5/6, 6/5, 1)
            if (Math.abs(iota - 1.0) < 0.05 || Math.abs(iota - 1.2) < 0.05 || Math.abs(iota - 0.833) < 0.05) {
                iotaItem.className = 'physics-item warning';
            } else {
                iotaItem.className = 'physics-item ok';
            }
            
            // Shear Update
            document.getElementById('shearValue').textContent = shear.toFixed(3);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONTROLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setupControls() {
            let isDragging = false;
            let prevX = 0, prevY = 0;
            
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', e => {
                isDragging = true;
                prevX = e.clientX;
                prevY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', e => {
                if (!isDragging) return;
                stellarator.rotation.y += (e.clientX - prevX) * 0.01;
                stellarator.rotation.x += (e.clientY - prevY) * 0.01;
                prevX = e.clientX;
                prevY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
            
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                camera.position.z = Math.max(10, Math.min(40, camera.position.z + e.deltaY * 0.02));
            });
            
            // Touch support
            canvas.addEventListener('touchstart', e => {
                isDragging = true;
                prevX = e.touches[0].clientX;
                prevY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchmove', e => {
                if (!isDragging) return;
                stellarator.rotation.y += (e.touches[0].clientX - prevX) * 0.01;
                stellarator.rotation.x += (e.touches[0].clientY - prevY) * 0.01;
                prevX = e.touches[0].clientX;
                prevY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchend', () => isDragging = false);
            
            // Slider controls
            document.getElementById('speed').addEventListener('input', e => {
                rotationSpeed = e.target.value / 5000;
            });
            
            document.getElementById('twist').addEventListener('input', e => {
                twistAmount = e.target.value / 100;
                createStellarator();
            });
            
            document.getElementById('plasmaIntensity').addEventListener('input', e => {
                plasmaIntensity = e.target.value / 100;
                createStellarator();
            });
            
            document.getElementById('helixTurns').addEventListener('input', e => {
                helixTurns = parseInt(e.target.value);
                document.getElementById('turnsValue').textContent = helixTurns;
                config.helixTurns = helixTurns;
                createStellarator();
            });
            
            document.getElementById('kelvinEps').addEventListener('input', e => {
                const val = e.target.value / 1000;
                config.kelvinResonance.epsilon2 = val;
                document.getElementById('epsValue').textContent = val.toFixed(3);
                createStellarator();
            });
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ANIMATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let lastPhysicsUpdate = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate && stellarator) {
                stellarator.rotation.y += rotationSpeed;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PLASMA PARTIKEL ANIMATION - Bewegung entlang Magnetfeldlinien
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            updatePlasmaParticles();
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PLASMA FADE ANIMATION - Weicher Ãœbergang bei Field Lines
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (plasmaGroup && showPlasma) {
                // Sanfte Interpolation der Plasma-OpazitÃ¤t
                if (Math.abs(plasmaCurrentOpacity - plasmaTargetOpacity) > 0.001) {
                    plasmaCurrentOpacity += (plasmaTargetOpacity - plasmaCurrentOpacity) * plasmaFadeSpeed;
                    
                    // Finde Plasma Core Mesh und aktualisiere Material
                    const plasmaCore = plasmaGroup.getObjectByName('plasmaCore');
                    if (plasmaCore && plasmaCore.material) {
                        plasmaCore.material.opacity = plasmaCurrentOpacity;
                        // Emissive IntensitÃ¤t auch anpassen fÃ¼r weicheren Effekt
                        plasmaCore.material.emissiveIntensity = 0.3 + (plasmaCurrentOpacity * 0.8);
                    }
                }
                
                // Sanfte Interpolation der Hot Core OpazitÃ¤t
                if (Math.abs(hotCoreCurrentOpacity - hotCoreTargetOpacity) > 0.001) {
                    hotCoreCurrentOpacity += (hotCoreTargetOpacity - hotCoreCurrentOpacity) * plasmaFadeSpeed;
                    
                    const hotCore = plasmaGroup.getObjectByName('hotCore');
                    if (hotCore && hotCore.material) {
                        hotCore.material.opacity = hotCoreCurrentOpacity;
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // HOT CORE GLOW LAYERS - Synchronisiertes Fading
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const glowOpacities = [0.6, 0.35, 0.15];
                    for (let i = 0; i < 3; i++) {
                        const glowLayer = plasmaGroup.getObjectByName(`hotCoreGlow${i}`);
                        if (glowLayer && glowLayer.material) {
                            glowLayer.material.opacity = glowOpacities[i] * hotCoreCurrentOpacity;
                        }
                    }
                }
            }
            
            // Update physics readout every 500ms
            const now = Date.now();
            if (now - lastPhysicsUpdate > 500) {
                updatePhysicsReadout();
                lastPhysicsUpdate = now;
            }
            
            renderer.render(scene, camera);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
        }
        
        function togglePlasma() {
            showPlasma = !showPlasma;
            if (plasmaGroup) plasmaGroup.visible = showPlasma;
        }
        
        function toggleCoils() {
            showCoils = !showCoils;
            if (coilGroup) coilGroup.visible = showCoils;
        }
        
        function resetView() {
            if (stellarator) {
                stellarator.rotation.set(0, 0, 0);
            }
            camera.position.set(0, 8, 18);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleFieldLines() {
            showFieldLines = !showFieldLines;
            const btn = document.getElementById('fieldBtn');
            
            if (showFieldLines) {
                createMagneticFieldLines();
                btn.textContent = 'ğŸ§² Field Lines Off';
                btn.classList.add('active');
                // Weicher Ãœbergang: Plasma dimmen
                plasmaTargetOpacity = 0.12;
                hotCoreTargetOpacity = 0.25;
            } else {
                if (fieldLinesGroup) fieldLinesGroup.visible = false;
                btn.textContent = 'ğŸ§² Field Lines On';
                btn.classList.remove('active');
                // Plasma zurÃ¼ck auf normale Sichtbarkeit
                plasmaTargetOpacity = 0.25;
                hotCoreTargetOpacity = 0.5;
            }
        }
        
        function togglePoincare() {
            showPoincare = !showPoincare;
            const canvas = document.getElementById('poincare-canvas');
            const closeBtn = document.getElementById('poincare-close');
            const btn = document.getElementById('poincareBtn');
            
            if (showPoincare) {
                canvas.style.display = 'block';
                closeBtn.style.display = 'block';
                drawPoincareSection();
                btn.classList.add('active');
            } else {
                canvas.style.display = 'none';
                closeBtn.style.display = 'none';
                btn.classList.remove('active');
            }
        }
        
        function toggleCrossSection() {
            showCrossSection = !showCrossSection;
            const canvas = document.getElementById('crosssection-canvas');
            const closeBtn = document.getElementById('crosssection-close');
            const btn = document.getElementById('crossBtn');
            
            if (showCrossSection) {
                canvas.style.display = 'block';
                closeBtn.style.display = 'block';
                drawCrossSectionView();
                btn.classList.add('active');
            } else {
                canvas.style.display = 'none';
                closeBtn.style.display = 'none';
                btn.classList.remove('active');
            }
        }
        
        function toggleTemperature() {
            showTemperature = !showTemperature;
            const btn = document.getElementById('tempBtn');
            
            if (showTemperature) {
                // Hide normal plasma, show temperature
                if (plasmaGroup) plasmaGroup.visible = false;
                createTemperatureProfile();
                btn.textContent = 'ğŸŒ¡ï¸ Temperature Off';
                btn.classList.add('active');
            } else {
                if (temperatureGroup) temperatureGroup.visible = false;
                if (plasmaGroup && showPlasma) plasmaGroup.visible = true;
                btn.textContent = 'ğŸŒ¡ï¸ Temperature On';
                btn.classList.remove('active');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VMEC EXPORT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function calculateFourierCoefficients() {
            const Bmn = [];
            const { mpol, ntor } = config.vmec;
            const base = config.minorRadius / config.majorRadius;
            
            for (let m = 0; m <= mpol; m++) {
                for (let n = -ntor; n <= ntor; n++) {
                    if (n % 6 === 0 || n === 0) {
                        let amplitude;
                        if (m === 0 && n === 0) amplitude = config.majorRadius;
                        else if (m === 1 && n === 0) amplitude = config.minorRadius;
                        else if (m === 0 && n === 6) amplitude = base * 0.05;
                        else if (m === 1 && n === 6) amplitude = base * 0.02;
                        else amplitude = base * Math.exp(-0.5 * (Math.abs(m) + Math.abs(n) / 6));
                        
                        if (Math.abs(amplitude) > 1e-10) {
                            Bmn.push({ m, n, rbc: amplitude, zbs: amplitude * 0.1 });
                        }
                    }
                }
            }
            return Bmn;
        }
        
        function exportVMECBoundary() {
            const Bmn = calculateFourierCoefficients();
            const { mpol, ntor, ns } = config.vmec;
            
            let vmecInput = `!----- HEXA-HELIX STELLARATOR VMEC INPUT -----
! Generated by Twin Code (Mensch + KI)
! Date: ${new Date().toISOString()}
! Golden Ratio Twist: ${twistAmount.toFixed(4)}
! Helix Turns: ${helixTurns}

&INDATA
  MGRID_FILE = 'none'
  LFREEB = F
  
  NFP = 6
  MPOL = ${mpol}
  NTOR = ${ntor}
  NS_ARRAY = ${ns}
  
  PHIEDGE = 1.0
  CURTOR = 0.0
  
  GAMMA = 0.0
  BLOAT = 1.0
  SPRES_PED = 1.0
  
  PRES_SCALE = 1.0
  AM = 1.0 0.0 0.0 0.0 0.0
  
  NCURR = 0
  
  ! === BOUNDARY COEFFICIENTS (N=6 SYMMETRY) ===
`;

            Bmn.forEach(({ m, n, rbc, zbs }) => {
                vmecInput += `  RBC(${n},${m}) = ${rbc.toFixed(6)}  ZBS(${n},${m}) = ${zbs.toFixed(6)}\n`;
            });

            vmecInput += `
/
&END
`;

            const blob = new Blob([vmecInput], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hexa_helix_vmec_input.txt';
            a.click();
            URL.revokeObjectURL(url);
            
            alert('VMEC Boundary File exported!');
        }
        
        function calculateIotaProfile() {
            const profiles = [];
            const numPoints = 50;
            
            for (let i = 0; i <= numPoints; i++) {
                const s = i / numPoints;
                const iotaAxis = config.helixTurns * config.twistAmount / config.numHelices;
                const shear = 0.15;
                const iota = iotaAxis * (1 + shear * s);
                profiles.push({ s, iota });
            }
            
            const iotaEdge = profiles[profiles.length - 1].iota;
            const warnings = [];
            
            if (Math.abs(iotaEdge - 1.2) < 0.05) {
                warnings.push('âš ï¸ Iota near 6/5 resonance!');
            }
            if (iotaEdge < config.vmec.iotaMin || iotaEdge > config.vmec.iotaMax) {
                warnings.push(`âš ï¸ Iota outside [${config.vmec.iotaMin}, ${config.vmec.iotaMax}]`);
            }
            
            return { profiles, warnings, iotaAxis: profiles[0].iota, iotaEdge };
        }
        
        function showIotaProfile() {
            const { profiles, warnings, iotaAxis, iotaEdge } = calculateIotaProfile();
            const statusDiv = document.getElementById('validationStatus');
            
            // Create a canvas-based iota profile visualization
            // Check if canvas already exists, if not create it
            let iotaCanvas = document.getElementById('iota-profile-canvas');
            if (!iotaCanvas) {
                iotaCanvas = document.createElement('canvas');
                iotaCanvas.id = 'iota-profile-canvas';
                iotaCanvas.width = 320;
                iotaCanvas.height = 180;
                iotaCanvas.style.cssText = 'border: 1px solid #3498db; border-radius: 6px; margin-top: 10px; background: #0a0a0a;';
                statusDiv.parentNode.insertBefore(iotaCanvas, statusDiv.nextSibling);
            }
            
            const ctx = iotaCanvas.getContext('2d');
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 320, 180);
            
            // Plot area
            const plotLeft = 45, plotRight = 300, plotTop = 25, plotBottom = 150;
            const plotWidth = plotRight - plotLeft;
            const plotHeight = plotBottom - plotTop;
            
            // Title
            ctx.fillStyle = '#3498db';
            ctx.font = 'bold 12px Segoe UI';
            ctx.fillText('Î¹ (Iota) Profile with Resonances', 10, 16);
            
            // Determine iota range for plot
            const iotaMin = Math.min(0.7, iotaAxis * 0.9);
            const iotaMax = Math.max(1.3, iotaEdge * 1.1);
            
            // Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Vertical grid lines
            for (let s = 0; s <= 1; s += 0.25) {
                const x = plotLeft + s * plotWidth;
                ctx.moveTo(x, plotTop); ctx.lineTo(x, plotBottom);
            }
            // Horizontal grid lines
            for (let iota = iotaMin; iota <= iotaMax; iota += 0.1) {
                const y = plotBottom - ((iota - iotaMin) / (iotaMax - iotaMin)) * plotHeight;
                ctx.moveTo(plotLeft, y); ctx.lineTo(plotRight, y);
            }
            ctx.stroke();
            
            // Axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(plotLeft, plotTop); ctx.lineTo(plotLeft, plotBottom); ctx.lineTo(plotRight, plotBottom);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px Segoe UI';
            ctx.fillText('s (norm. flux)', plotLeft + plotWidth/2 - 30, 170);
            ctx.save();
            ctx.translate(12, plotTop + plotHeight/2 + 10);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Î¹ (iota)', 0, 0);
            ctx.restore();
            
            // X-axis ticks
            ctx.fillStyle = '#666';
            ctx.font = '9px Segoe UI';
            for (let s = 0; s <= 1; s += 0.25) {
                const x = plotLeft + s * plotWidth;
                ctx.fillText(s.toFixed(2), x - 10, plotBottom + 12);
            }
            
            // Y-axis ticks
            for (let iota = iotaMin; iota <= iotaMax; iota += 0.1) {
                const y = plotBottom - ((iota - iotaMin) / (iotaMax - iotaMin)) * plotHeight;
                ctx.fillText(iota.toFixed(1), plotLeft - 25, y + 3);
            }
            
            // === RESONANCE LINES ===
            const resonances = [
                { value: 5/6, label: '5/6', color: '#e74c3c' },
                { value: 1.0, label: '1/1', color: '#e74c3c' },
                { value: 6/5, label: '6/5', color: '#e74c3c' },
                { value: 5/4, label: '5/4', color: '#f39c12' },
                { value: 4/5, label: '4/5', color: '#f39c12' },
                { value: 7/6, label: '7/6', color: '#f39c12' }
            ];
            
            ctx.setLineDash([5, 3]);
            resonances.forEach(res => {
                if (res.value >= iotaMin && res.value <= iotaMax) {
                    const y = plotBottom - ((res.value - iotaMin) / (iotaMax - iotaMin)) * plotHeight;
                    ctx.strokeStyle = res.color;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(plotLeft, y);
                    ctx.lineTo(plotRight, y);
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = res.color;
                    ctx.font = 'bold 9px Segoe UI';
                    ctx.fillText(res.label, plotRight + 3, y + 3);
                }
            });
            ctx.setLineDash([]);
            
            // === IOTA PROFILE CURVE ===
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 3;
            ctx.beginPath();
            profiles.forEach((p, i) => {
                const x = plotLeft + p.s * plotWidth;
                const y = plotBottom - ((p.iota - iotaMin) / (iotaMax - iotaMin)) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Mark axis and edge values
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(plotLeft, plotBottom - ((iotaAxis - iotaMin) / (iotaMax - iotaMin)) * plotHeight, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(plotRight, plotBottom - ((iotaEdge - iotaMin) / (iotaMax - iotaMin)) * plotHeight, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Update status div
            if (warnings.length > 0) {
                statusDiv.className = 'validation-box warning';
                statusDiv.innerHTML = `
                    <strong>âš ï¸ Resonance Warning:</strong><br>
                    ${warnings.join('<br>')}<br>
                    <small>Î¹(0) = ${iotaAxis.toFixed(4)} â†’ Î¹(edge) = ${iotaEdge.toFixed(4)}</small>
                `;
            } else {
                statusDiv.className = 'validation-box';
                statusDiv.innerHTML = `
                    <strong>âœ… Iota Profile OK:</strong><br>
                    Î¹(axis) = ${iotaAxis.toFixed(4)} | Î¹(edge) = ${iotaEdge.toFixed(4)}<br>
                    <small>Avoiding low-order resonances (n/m)</small>
                `;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STL EXPORT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function exportToSTL() {
            let output = 'solid hexa_helix\n';
            
            coilGroup.traverse(obj => {
                if (obj.isMesh && obj.geometry) {
                    const geo = obj.geometry;
                    const pos = geo.getAttribute('position');
                    const idx = geo.index;
                    
                    if (idx) {
                        for (let i = 0; i < idx.count; i += 3) {
                            const a = idx.getX(i), b = idx.getX(i+1), c = idx.getX(i+2);
                            const vA = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(obj.matrixWorld);
                            const vB = new THREE.Vector3().fromBufferAttribute(pos, b).applyMatrix4(obj.matrixWorld);
                            const vC = new THREE.Vector3().fromBufferAttribute(pos, c).applyMatrix4(obj.matrixWorld);
                            
                            const cb = new THREE.Vector3().subVectors(vC, vB);
                            const ab = new THREE.Vector3().subVectors(vA, vB);
                            const normal = cb.cross(ab).normalize();
                            
                            output += `facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                            output += `  outer loop\n`;
                            output += `    vertex ${vA.x} ${vA.y} ${vA.z}\n`;
                            output += `    vertex ${vB.x} ${vB.y} ${vB.z}\n`;
                            output += `    vertex ${vC.x} ${vC.y} ${vC.z}\n`;
                            output += `  endloop\n`;
                            output += `endfacet\n`;
                        }
                    }
                }
            });
            
            output += 'endsolid hexa_helix\n';
            
            const blob = new Blob([output], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hexa_helix_coils.stl';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize
        window.onload = init;
    </script>
</body>
</html>

